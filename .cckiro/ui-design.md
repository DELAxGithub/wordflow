# IELTS Writing Practice App - UI/UXË®≠Ë®àÊõ∏

## üé® UIË®≠Ë®àÊ¶ÇË¶Å

### „Éá„Ç∂„Ç§„É≥„Éï„Ç£„É≠„ÇΩ„Éï„Ç£„Éº
**„ÄåÂ≠¶Áøí„Å´ÈõÜ‰∏≠„Åß„Åç„Çã„Éü„Éã„Éû„É´„ÅßÊ©üËÉΩÁöÑ„Å™„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„Äç**

#### Ê†∏ÂøÉÂéüÂâá
1. **Focus-First**: Á∑¥Áøí„Å´ÈõÜ‰∏≠„Åß„Åç„ÇãÁí∞Â¢É„ÅÆÊèê‰æõ
2. **Immediate Feedback**: „É™„Ç¢„É´„Çø„Ç§„É†„Å™„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØË°®Á§∫
3. **Cognitive Load Reduction**: Ë™çÁü•Ë≤†Ëç∑„ÇíÊúÄÂ∞èÂåñ„Åó„Åü„Ç∑„É≥„Éó„É´Ë®≠Ë®à  
4. **IELTS-Optimized**: IELTSÂèóÈ®ìËÄÖ„ÅÆÂ≠¶Áøí„Éï„É≠„Éº„Å´ÊúÄÈÅ©Âåñ

#### „Éá„Ç∂„Ç§„É≥ÊåáÈáù
- **ÊÉÖÂ†±ÈöéÂ±§**: ÈáçË¶ÅÂ∫¶„Å´Âøú„Åò„ÅüÊÉÖÂ†±„ÅÆË¶ñË¶öÁöÑÂÑ™ÂÖàÈ†Ü‰Ωç
- **‰∏ÄË≤´ÊÄß**: ÂÖ®ÁîªÈù¢„Åß„ÅÆÁµ±‰∏Ä„Åï„Çå„Åü„Éá„Ç∂„Ç§„É≥„Éë„Çø„Éº„É≥
- **ÂøúÁ≠îÊÄß**: Âç≥Â∫ß„Å™„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„Å´„Çà„Çã„É¶„Éº„Ç∂„ÉºÂÆâÂøÉÊÑü
- **„Ç¢„ÇØ„Çª„Ç∑„Éì„É™„ÉÜ„Ç£**: ÂÖ®„É¶„Éº„Ç∂„Éº„ÅåÂà©Áî®ÂèØËÉΩ„Å™„Ç§„É≥„ÇØ„É´„Éº„Ç∑„Éñ„Éá„Ç∂„Ç§„É≥

---

## üì± ÁîªÈù¢ÊßãÊàê„ÉªÊÉÖÂ†±„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£

### „É°„Ç§„É≥ÁîªÈù¢ÊßãÊàê
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    App Header                           ‚îÇ
‚îÇ  IELTS Practice  [Settings‚öôÔ∏è] [Progressüìä] [Help‚ùì]     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ   Target Text   ‚îÇ        Input Area               ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ   (Ê®°ÁØÑËß£Á≠î)      ‚îÇ      (ÂÖ•Âäõ„Ç®„É™„Ç¢)                ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                 ‚îÇ                                 ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ   250 words     ‚îÇ   + Real-time typing            ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ   + Structure   ‚îÇ   + Auto-scroll                 ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ   + TTS Control ‚îÇ   + Difference highlight        ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ   + Highlight   ‚îÇ   + Word count display          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                 ‚îÇ                                 ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ              Live Statistics Panel                  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚è±Ô∏è 1:23  üìä 45WPM  üéØ 92%  üèÜ 0.85  üìà 85% Done    ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Timer   Speed   Accuracy  Quality   Progress      ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ               Error Analysis Panel                  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  üî¥ Spelling: 3  üü† Grammar: 2  üîµ Punct: 1       ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  üü£ Capital: 0   üü§ Article: 1   üü¢ Other: 0      ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ÁîªÈù¢ÊØîÁéá„Éª„É¨„Ç§„Ç¢„Ç¶„Éà
- **Target Text Area**: 40% (Â∑¶ÂÅ¥)
- **Input Area**: 40% (Âè≥ÂÅ¥)  
- **Statistics Panel**: 15% (‰∏ãÈÉ®)
- **Error Analysis**: 5% (ÊúÄ‰∏ãÈÉ®)

---

## üñºÔ∏è Ë©≥Á¥∞ÁîªÈù¢Ë®≠Ë®à

### 1. „É°„Ç§„É≥Á∑¥ÁøíÁîªÈù¢ (TypingPracticeView)

#### Target Text Area (Â∑¶ÂÅ¥„Éë„Éç„É´)
```swift
struct TargetTextPanel: View {
    @State private var highlightedSentence: Int? = nil
    @State private var showStructure: Bool = true
    
    var body: some View {
        VStack(spacing: 0) {
            // Header with controls
            HStack {
                Text("Target Text (250 words)")
                    .font(.headline)
                    .foregroundColor(.primary)
                
                Spacer()
                
                // Structure toggle
                Button(action: { showStructure.toggle() }) {
                    Image(systemName: showStructure ? "list.bullet" : "text.alignleft")
                }
                .help("Toggle structure view")
            }
            .padding(.bottom, 8)
            
            Divider()
            
            // Text with highlighting
            ScrollView {
                if showStructure {
                    StructuredTextView(text: targetText, 
                                     highlightedSentence: highlightedSentence)
                } else {
                    ContinuousTextView(text: targetText,
                                     highlightedSentence: highlightedSentence)
                }
            }
            
            Divider()
            
            // TTS Controls
            TTSControlPanel()
        }
        .padding()
        .background(Color(NSColor.textBackgroundColor))
        .cornerRadius(12)
    }
}
```

#### Input Area (Âè≥ÂÅ¥„Éë„Éç„É´)
```swift
struct InputArea: View {
    @Binding var inputText: String
    @State private var textEditor: NSTextView?
    
    var body: some View {
        VStack(spacing: 0) {
            // Header with word count
            HStack {
                Text("Your Input")
                    .font(.headline)
                
                Spacer()
                
                Text("\(inputText.wordCount)/250 words")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            .padding(.bottom, 8)
            
            Divider()
            
            // Real-time difference highlighting text editor
            DifferenceHighlightTextEditor(
                text: $inputText,
                targetText: targetText,
                fontSize: 16,
                fontFamily: .systemFont
            )
            
            Divider()
            
            // Input statistics
            HStack {
                Text("Characters: \(inputText.count)")
                Spacer()
                Text("Sentences: \(inputText.sentenceCount)")
                Spacer()  
                Text("Paragraphs: \(inputText.paragraphCount)")
            }
            .font(.caption)
            .foregroundColor(.secondary)
            .padding(.top, 8)
        }
        .padding()
        .background(Color(NSColor.textBackgroundColor))
        .cornerRadius(12)
    }
}
```

#### Live Statistics Panel
```swift
struct LiveStatisticsPanel: View {
    @ObservedObject var testManager: TypingTestManager
    
    var body: some View {
        HStack(spacing: 20) {
            StatisticCard(
                icon: "‚è±Ô∏è",
                title: "Timer",
                value: testManager.formattedRemainingTime,
                color: timeColor
            )
            
            StatisticCard(
                icon: "üìä", 
                title: "WPM",
                value: String(format: "%.0f", testManager.currentWPM),
                color: .blue
            )
            
            StatisticCard(
                icon: "üéØ",
                title: "Accuracy", 
                value: String(format: "%.0f%%", testManager.accuracy),
                color: .green
            )
            
            StatisticCard(
                icon: "üèÜ",
                title: "Quality",
                value: String(format: "%.2f", testManager.qualityIndex),
                color: .purple
            )
            
            StatisticCard(
                icon: "üìà",
                title: "Progress",
                value: String(format: "%.0f%%", testManager.completionPercentage),
                color: .orange
            )
        }
        .padding(.vertical, 12)
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
    }
}
```

---

### 2. TTSÂà∂Âæ°„Éë„Éç„É´

```swift
struct TTSControlPanel: View {
    @StateObject private var ttsManager = TTSManager()
    @State private var playbackSpeed: Float = 1.0
    @State private var selectedVoice: VoiceLanguage = .usEnglish
    
    var body: some View {
        VStack(spacing: 12) {
            // Main controls
            HStack(spacing: 16) {
                // Play/Pause/Stop buttons  
                HStack(spacing: 8) {
                    Button(action: ttsManager.playFullText) {
                        Image(systemName: "play.fill")
                            .font(.title2)
                    }
                    .disabled(ttsManager.isPlaying)
                    
                    Button(action: ttsManager.pauseSpeech) {
                        Image(systemName: "pause.fill")
                            .font(.title2)
                    }
                    .disabled(!ttsManager.isPlaying)
                    
                    Button(action: ttsManager.stopSpeech) {
                        Image(systemName: "stop.fill")
                            .font(.title2)
                    }
                }
                
                Divider()
                    .frame(height: 20)
                
                // Playback modes
                VStack {
                    Text("Mode")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    Picker("Mode", selection: $ttsManager.playbackMode) {
                        Text("Full").tag(PlaybackMode.full)
                        Text("Sentence").tag(PlaybackMode.sentence)
                        Text("Phrase").tag(PlaybackMode.phrase)
                    }
                    .pickerStyle(.segmented)
                    .frame(width: 150)
                }
                
                Divider()
                    .frame(height: 20)
                
                // Speed control
                VStack {
                    Text("Speed: \(String(format: "%.1fx", playbackSpeed))")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    Slider(value: $playbackSpeed, in: 0.5...2.0, step: 0.25)
                        .frame(width: 100)
                        .onChange(of: playbackSpeed) { _, newValue in
                            ttsManager.setSpeed(newValue)
                        }
                }
            }
            
            // Voice selection
            HStack {
                Text("Voice:")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Picker("Voice", selection: $selectedVoice) {
                    Text("üá∫üá∏ US English").tag(VoiceLanguage.usEnglish)
                    Text("üá¨üáß UK English").tag(VoiceLanguage.ukEnglish)
                }
                .pickerStyle(.menu)
                .onChange(of: selectedVoice) { _, newVoice in
                    ttsManager.setVoiceLanguage(newVoice)
                }
                
                Spacer()
                
                // Progress indicator
                if ttsManager.isPlaying {
                    HStack(spacing: 4) {
                        Text("Playing...")
                            .font(.caption)
                            .foregroundColor(.blue)
                        
                        ProgressView()
                            .scaleEffect(0.7)
                    }
                }
            }
        }
        .padding(12)
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
    }
}
```

---

### 3. „Ç®„É©„ÉºÂàÜÊûê„Éë„Éç„É´

```swift
struct ErrorAnalysisPanel: View {
    let errorResults: [ErrorResult]
    @State private var selectedErrorType: ErrorType?
    
    private var errorCounts: [ErrorType: Int] {
        Dictionary(grouping: errorResults, by: { $0.type })
            .mapValues { $0.count }
    }
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text("Error Analysis")
                    .font(.headline)
                    .foregroundColor(.primary)
                
                Spacer()
                
                Text("Total: \(errorResults.count) errors")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            // Error category chips
            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 4), 
                      spacing: 8) {
                ForEach(ErrorType.allCases, id: \.self) { errorType in
                    ErrorCategoryChip(
                        errorType: errorType,
                        count: errorCounts[errorType] ?? 0,
                        isSelected: selectedErrorType == errorType
                    ) {
                        selectedErrorType = selectedErrorType == errorType ? nil : errorType
                    }
                }
            }
            
            // Error details (if category selected)
            if let selectedType = selectedErrorType,
               let errors = errorCounts[selectedType], errors > 0 {
                
                Divider()
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("\(selectedType.displayName) Errors")
                        .font(.subheadline)
                        .fontWeight(.medium)
                    
                    ForEach(errorResults.filter { $0.type == selectedType }, 
                           id: \.position) { error in
                        ErrorDetailRow(error: error)
                    }
                }
            }
        }
        .padding(12)
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
    }
}

struct ErrorCategoryChip: View {
    let errorType: ErrorType
    let count: Int
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack(spacing: 4) {
                Text(errorType.icon)
                    .font(.caption)
                
                Text(errorType.shortName)
                    .font(.caption)
                    .fontWeight(.medium)
                
                Text("\(count)")
                    .font(.caption)
                    .fontWeight(.bold)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 2)
                    .background(Color.primary.opacity(0.1))
                    .cornerRadius(8)
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .background(isSelected ? errorType.color.opacity(0.2) : Color.clear)
            .overlay(
                RoundedRectangle(cornerRadius: 6)
                    .stroke(errorType.color, lineWidth: isSelected ? 2 : 1)
            )
        }
        .buttonStyle(.plain)
    }
}
```

---

### 4. Â∑ÆÂàÜ„Éè„Ç§„É©„Ç§„ÉàË°®Á§∫„Ç∑„Çπ„ÉÜ„É†

```swift
struct DifferenceHighlightTextEditor: NSViewRepresentable {
    @Binding var text: String
    let targetText: String
    let fontSize: CGFloat
    let fontFamily: NSFont
    
    func makeNSView(context: Context) -> NSScrollView {
        let scrollView = NSScrollView()
        let textView = NSTextView()
        
        // Text view configuration
        textView.delegate = context.coordinator
        textView.isRichText = true
        textView.allowsUndo = true
        textView.font = fontFamily
        textView.textColor = NSColor.labelColor
        textView.backgroundColor = NSColor.textBackgroundColor
        
        // Real-time highlighting
        textView.textStorage?.delegate = context.coordinator
        
        scrollView.documentView = textView
        scrollView.hasVerticalScroller = true
        
        return scrollView
    }
    
    func updateNSView(_ nsView: NSScrollView, context: Context) {
        guard let textView = nsView.documentView as? NSTextView else { return }
        
        if textView.string != text {
            textView.string = text
            applyDifferenceHighlighting(to: textView)
        }
    }
    
    private func applyDifferenceHighlighting(to textView: NSTextView) {
        let attributedString = NSMutableAttributedString(string: text)
        let targetWords = targetText.components(separatedBy: .whitespacesAndNewlines)
        let inputWords = text.components(separatedBy: .whitespacesAndNewlines)
        
        // Apply character-by-character comparison
        for (index, character) in text.enumerated() {
            let range = NSRange(location: index, length: 1)
            
            if index < targetText.count {
                let targetChar = targetText[targetText.index(targetText.startIndex, offsetBy: index)]
                
                if character == targetChar {
                    // Correct character - green background
                    attributedString.addAttribute(.backgroundColor, 
                                                value: NSColor.systemGreen.withAlphaComponent(0.3), 
                                                range: range)
                } else {
                    // Incorrect character - red background
                    attributedString.addAttribute(.backgroundColor, 
                                                value: NSColor.systemRed.withAlphaComponent(0.3), 
                                                range: range)
                    
                    // Add underline for emphasis
                    attributedString.addAttribute(.underlineStyle, 
                                                value: NSUnderlineStyle.single.rawValue, 
                                                range: range)
                }
            } else {
                // Extra characters - pink background
                attributedString.addAttribute(.backgroundColor, 
                                            value: NSColor.systemPink.withAlphaComponent(0.3), 
                                            range: range)
            }
        }
        
        textView.textStorage?.setAttributedString(attributedString)
    }
}
```

---

### 5. Âæ©Áøí„É™„Çπ„ÉàÁîªÈù¢

```swift
struct ReviewListView: View {
    @StateObject private var reviewManager = ReviewManager()
    @State private var selectedErrorType: ErrorType?
    @State private var showingMasteredItems = false
    
    var filteredReviewItems: [ReviewItem] {
        var items = reviewManager.reviewItems
        
        if let errorType = selectedErrorType {
            items = items.filter { $0.errorType == errorType }
        }
        
        if !showingMasteredItems {
            items = items.filter { $0.masteryLevel != .mastered }
        }
        
        return items.sorted { $0.priority > $1.priority }
    }
    
    var body: some View {
        VStack(spacing: 16) {
            // Header with filters
            HStack {
                Text("Review List")
                    .font(.title2)
                    .fontWeight(.semibold)
                
                Spacer()
                
                // Error type filter
                Picker("Filter", selection: $selectedErrorType) {
                    Text("All Errors").tag(nil as ErrorType?)
                    ForEach(ErrorType.allCases, id: \.self) { type in
                        Text(type.displayName).tag(type as ErrorType?)
                    }
                }
                .pickerStyle(.menu)
                .frame(width: 150)
                
                // Show mastered toggle
                Toggle("Show Mastered", isOn: $showingMasteredItems)
            }
            
            // Statistics bar
            HStack(spacing: 20) {
                StatCard(title: "Total Items", 
                        value: "\(reviewManager.reviewItems.count)")
                StatCard(title: "Need Practice", 
                        value: "\(reviewManager.needsPracticeCount)")
                StatCard(title: "Mastered", 
                        value: "\(reviewManager.masteredCount)")
                StatCard(title: "Success Rate", 
                        value: "\(Int(reviewManager.overallSuccessRate * 100))%")
            }
            
            Divider()
            
            // Review items list
            ScrollView {
                LazyVStack(spacing: 12) {
                    ForEach(filteredReviewItems, id: \.id) { item in
                        ReviewItemCard(item: item) {
                            reviewManager.markAsReviewed(item)
                        }
                    }
                    
                    if filteredReviewItems.isEmpty {
                        EmptyReviewListView()
                    }
                }
                .padding()
            }
        }
        .padding()
        .onAppear {
            reviewManager.loadReviewItems()
        }
    }
}

struct ReviewItemCard: View {
    let item: ReviewItem  
    let onReviewed: () -> Void
    @StateObject private var ttsManager = TTSManager()
    
    var body: some View {
        HStack(spacing: 12) {
            // Error type indicator
            VStack {
                Text(item.errorType.icon)
                    .font(.title2)
                
                Text(item.errorType.shortName)
                    .font(.caption)
                    .multilineTextAlignment(.center)
            }
            .frame(width: 60)
            .padding(8)
            .background(item.errorType.color.opacity(0.1))
            .cornerRadius(8)
            
            // Error details
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text("Expected:")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    Text(item.expectedText)
                        .font(.body)
                        .fontWeight(.medium)
                        .foregroundColor(.green)
                }
                
                HStack {
                    Text("Your input:")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    Text(item.actualText)
                        .font(.body)
                        .fontWeight(.medium)
                        .foregroundColor(.red)
                }
                
                if !item.suggestion.isEmpty {
                    HStack {
                        Text("Tip:")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        Text(item.suggestion)
                            .font(.caption)
                            .foregroundColor(.blue)
                    }
                }
            }
            
            Spacer()
            
            // Mastery level and controls
            VStack(spacing: 8) {
                MasteryLevelIndicator(level: item.masteryLevel)
                
                HStack(spacing: 4) {
                    // TTS button
                    Button(action: { 
                        ttsManager.playPhrase(item.expectedText) 
                    }) {
                        Image(systemName: "speaker.2")
                            .font(.caption)
                    }
                    .buttonStyle(.borderless)
                    .help("Play pronunciation")
                    
                    // Mark as reviewed
                    Button(action: onReviewed) {
                        Image(systemName: "checkmark.circle")
                            .font(.caption)
                    }
                    .buttonStyle(.borderless)
                    .help("Mark as reviewed")
                }
            }
        }
        .padding(12)
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(item.errorType.color.opacity(0.3), lineWidth: 1)
        )
    }
}
```

---

## üé® „Éì„Ç∏„É•„Ç¢„É´„Éá„Ç∂„Ç§„É≥„Ç∑„Çπ„ÉÜ„É†

### „Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà

#### „Éó„É©„Ç§„Éû„É™„Ç´„É©„Éº
```swift
enum AppColors {
    // Brand colors
    static let primary = Color(#colorLiteral(red: 0.0, green: 0.48, blue: 1.0, alpha: 1.0))      // #007AFF
    static let secondary = Color(#colorLiteral(red: 0.56, green: 0.56, blue: 0.58, alpha: 1.0))  // #8E8E93
    
    // Semantic colors
    static let success = Color(#colorLiteral(red: 0.20, green: 0.78, blue: 0.35, alpha: 1.0))    // #34C759
    static let warning = Color(#colorLiteral(red: 1.0, green: 0.58, blue: 0.0, alpha: 1.0))     // #FF9500
    static let error = Color(#colorLiteral(red: 1.0, green: 0.23, blue: 0.19, alpha: 1.0))      // #FF3B30
    
    // Error type colors
    static let spelling = error                      // #FF3B30 (Ëµ§)
    static let grammar = warning                     // #FF9500 („Ç™„É¨„É≥„Ç∏)
    static let punctuation = primary                 // #007AFF (Èùí)
    static let capitalization = Color(.systemPurple) // #AF52DE (Á¥´)
}
```

#### „ÉÄ„Éº„ÇØ„É¢„Éº„ÉâÂØæÂøú
```swift
extension AppColors {
    static let adaptiveBackground = Color(NSColor.textBackgroundColor)
    static let adaptiveText = Color(NSColor.labelColor)
    static let adaptiveSecondaryText = Color(NSColor.secondaryLabelColor)
    static let adaptiveCardBackground = Color(NSColor.controlBackgroundColor)
}
```

### „Çø„Ç§„Éù„Ç∞„É©„Éï„Ç£

```swift
enum AppFonts {
    // Text editor fonts (monospace for typing)
    static let editorFont = NSFont.monospacedSystemFont(ofSize: 16, weight: .regular)
    static let targetTextFont = NSFont.systemFont(ofSize: 16, weight: .regular)
    
    // UI fonts
    static let titleFont = Font.title2.weight(.semibold)
    static let headlineFont = Font.headline
    static let bodyFont = Font.body
    static let captionFont = Font.caption
    static let statisticValueFont = Font.title3.weight(.semibold)
    static let statisticLabelFont = Font.caption.weight(.medium)
}
```

### „Ç¢„Ç§„Ç≥„É≥„Ç∑„Çπ„ÉÜ„É†

```swift
enum AppIcons {
    // Navigation
    static let settings = "gearshape"
    static let progress = "chart.bar"
    static let help = "questionmark.circle"
    
    // TTS controls
    static let play = "play.fill"
    static let pause = "pause.fill"
    static let stop = "stop.fill"
    static let speaker = "speaker.2"
    
    // Statistics
    static let timer = "timer"
    static let speed = "speedometer"  
    static let accuracy = "target"
    static let quality = "trophy"
    static let progress = "chart.line.uptrend.xyaxis"
    
    // Error types
    static let spelling = "textformat.abc"
    static let grammar = "text.badge.checkmark"
    static let punctuation = "exclamationmark.triangle"
    static let capitalization = "textformat"
}
```

---

## üìê „É¨„Ç§„Ç¢„Ç¶„Éà„Éª„É¨„Çπ„Éù„É≥„Ç∑„Éñ„Éá„Ç∂„Ç§„É≥

### ÁîªÈù¢„Çµ„Ç§„Ç∫ÂØæÂøú

#### ÊúÄÂ∞è„Çµ„Ç§„Ç∫: 1280x720
```swift
struct ResponsiveLayout {
    static let minWindowWidth: CGFloat = 1280
    static let minWindowHeight: CGFloat = 720
    
    // Component sizing
    static let targetTextMinWidth: CGFloat = 500
    static let inputAreaMinWidth: CGFloat = 500
    static let statisticsPanelHeight: CGFloat = 80
    static let errorPanelHeight: CGFloat = 120
}
```

#### „É¨„Çπ„Éù„É≥„Ç∑„ÉñÂØæÂøú
```swift
struct AdaptiveLayout: View {
    let screenSize: CGSize
    
    private var useCompactLayout: Bool {
        screenSize.width < 1400
    }
    
    var body: some View {
        if useCompactLayout {
            // Vertical stack for smaller screens
            VStack(spacing: 12) {
                HStack(spacing: 12) {
                    TargetTextPanel()
                    InputArea()
                }
                
                VStack(spacing: 8) {
                    StatisticsPanel()
                    ErrorAnalysisPanel()
                }
            }
        } else {
            // Standard horizontal layout
            VStack(spacing: 12) {
                HStack(spacing: 12) {
                    TargetTextPanel()
                        .frame(minWidth: 600)
                    InputArea()
                        .frame(minWidth: 600)
                }
                
                HStack(spacing: 12) {
                    StatisticsPanel()
                    ErrorAnalysisPanel()
                }
            }
        }
    }
}
```

---

## ‚ôø „Ç¢„ÇØ„Çª„Ç∑„Éì„É™„ÉÜ„Ç£Ë®≠Ë®à

### VoiceOverÂØæÂøú
```swift
extension View {
    func accessibilityConfiguration() -> some View {
        self
            .accessibilityElement(children: .combine)
            .accessibilityLabel("IELTS typing practice")
            .accessibilityHint("Practice typing IELTS essay with real-time feedback")
    }
}

struct AccessibleStatisticCard: View {
    let title: String
    let value: String
    
    var body: some View {
        VStack {
            Text(value)
                .font(.title3)
                .fontWeight(.semibold)
            
            Text(title)
                .font(.caption)
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(title): \(value)")
        .accessibilityHint("Current \(title.lowercased()) statistic")
    }
}
```

### „Ç≠„Éº„Éú„Éº„Éâ„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥
```swift
struct KeyboardNavigationView: View {
    @FocusState private var focusedField: FocusField?
    
    enum FocusField {
        case targetText, inputArea, ttsControls, statistics
    }
    
    var body: some View {
        VStack {
            TargetTextPanel()
                .focused($focusedField, equals: .targetText)
                .onKeyPress(.tab) { focusedField = .inputArea; return .handled }
            
            InputArea()
                .focused($focusedField, equals: .inputArea)
                .onKeyPress(.tab) { focusedField = .ttsControls; return .handled }
            
            TTSControlPanel()
                .focused($focusedField, equals: .ttsControls)
                .onKeyPress(.tab) { focusedField = .statistics; return .handled }
                
            StatisticsPanel()
                .focused($focusedField, equals: .statistics)
                .onKeyPress(.tab) { focusedField = .targetText; return .handled }
        }
    }
}
```

### È´ò„Ç≥„É≥„Éà„É©„Çπ„Éà„É¢„Éº„Éâ
```swift
@Environment(\.accessibilityDifferentiateWithoutColor) var differentiateWithoutColor
@Environment(\.accessibilityReduceTransparency) var reduceTransparency

struct AccessibleErrorHighlight: View {
    let errorType: ErrorType
    
    var body: some View {
        if differentiateWithoutColor {
            // Use patterns instead of just colors
            HStack {
                errorType.patternIcon
                Text(errorType.displayName)
            }
            .padding(4)
            .overlay(
                RoundedRectangle(cornerRadius: 4)
                    .stroke(Color.primary, lineWidth: 2)
                    .background(errorType.pattern)
            )
        } else {
            // Standard color-based highlight
            Text(errorType.displayName)
                .padding(4)
                .background(errorType.color.opacity(0.3))
                .cornerRadius(4)
        }
    }
}
```

---

## üé≠ „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Éª„Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥Ë®≠Ë®à

### „Éû„Ç§„ÇØ„É≠„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
```swift
struct AnimatedStatisticCard: View {
    let value: Double
    @State private var animatedValue: Double = 0
    
    var body: some View {
        Text(String(format: "%.0f", animatedValue))
            .font(.title3)
            .fontWeight(.semibold)
            .contentTransition(.numericText())
            .onAppear {
                withAnimation(.easeInOut(duration: 0.5)) {
                    animatedValue = value
                }
            }
            .onChange(of: value) { _, newValue in
                withAnimation(.easeInOut(duration: 0.3)) {
                    animatedValue = newValue
                }
            }
    }
}
```

### „Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
```swift
struct TypingFeedbackView: View {
    @State private var lastCorrectInput: String = ""
    @State private var showSuccess: Bool = false
    
    var body: some View {
        ZStack {
            InputArea()
            
            // Success feedback
            if showSuccess {
                HStack {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                        .font(.title)
                    
                    Text("Great!")
                        .fontWeight(.semibold)
                        .foregroundColor(.green)
                }
                .scaleEffect(showSuccess ? 1.2 : 0.8)
                .opacity(showSuccess ? 1 : 0)
                .animation(.spring(duration: 0.6), value: showSuccess)
            }
        }
        .onChange(of: inputText) { _, newText in
            if isCorrectSequence(newText) {
                triggerSuccessFeedback()
            }
        }
    }
    
    private func triggerSuccessFeedback() {
        showSuccess = true
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            showSuccess = false
        }
    }
}
```

---

## üé¨ „É¶„Éº„Ç∂„Éº„Éï„É≠„Éº„Éª„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥

### ÂàùÂõûËµ∑Âãï„Éï„É≠„Éº
```
App Launch ‚Üí Welcome Screen ‚Üí Tutorial ‚Üí First Practice ‚Üí Results ‚Üí Review Setup
     ‚Üì              ‚Üì             ‚Üì            ‚Üì           ‚Üì           ‚Üì
   1 sec         5 sec         30 sec       2 min      10 sec      20 sec
```

### Êó•Â∏∏Âà©Áî®„Éï„É≠„Éº
```
App Launch ‚Üí Dashboard ‚Üí Practice Selection ‚Üí Typing Test ‚Üí Results ‚Üí Review
     ‚Üì           ‚Üì              ‚Üì               ‚Üì          ‚Üì         ‚Üì
   1 sec       5 sec         10 sec          2 min     10 sec    Optional
```

### „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥ÊßãÈÄ†
```swift
enum AppDestination: Hashable {
    case dashboard
    case practice(IELTSTask)
    case results(TypingResult)
    case reviewList
    case settings
    case statistics
    case help
}

@main
struct IELTSPracticeApp: App {
    @StateObject private var navigationManager = NavigationManager()
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(navigationManager)
                .onOpenURL { url in
                    navigationManager.handle(url)
                }
        }
        .windowResizability(.contentSize)
        .windowStyle(.titleBar)
    }
}
```

---

*„Åì„ÅÆ UI/UXË®≠Ë®àÊõ∏„ÅØ„ÄÅIELTSÂèóÈ®ìËÄÖ„ÅÆÂ≠¶Áøí„Éï„É≠„Éº„Å®Ë™çÁü•Ë≤†Ëç∑„ÇíÊúÄÂ∞èÂåñ„Åó„ÄÅÂäπÊûúÁöÑ„Å™Á∑¥ÁøíÁí∞Â¢É„ÇíÊèê‰æõ„Åô„ÇãÂåÖÊã¨ÁöÑ„Å™„Éá„Ç∂„Ç§„É≥„Ç∑„Çπ„ÉÜ„É†„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÖ®„Å¶„ÅÆ„Éá„Ç∂„Ç§„É≥Ê±∫ÂÆö„ÅØ„ÄÅ„É¶„Éº„Ç∂„Éì„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà„Å®„Ç¢„ÇØ„Çª„Ç∑„Éì„É™„ÉÜ„Ç£„Ç¨„Ç§„Éâ„É©„Ç§„É≥„Å´Âü∫„Å•„ÅÑ„Å¶ÊúÄÈÅ©Âåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ*