# IELTS Writing Practice App - MVPç‰ˆå®Ÿè£…è¨ˆç”»æ›¸

## ğŸ“‹ å®Ÿè£…æ¦‚è¦

ã“ã®æ–‡æ›¸ã§ã¯ã€IELTS Writing Practice App MVPç‰ˆã®è¿…é€Ÿãªå®Ÿè£…è¨ˆç”»ã€é–‹ç™ºãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ã€ãƒªã‚½ãƒ¼ã‚¹é…åˆ†ã‚’å®šç¾©ã—ã¾ã™ã€‚

### MVPç‰ˆé–‹ç™ºæ–¹é‡
- **ã‚·ãƒ³ãƒ—ãƒ«ç¬¬ä¸€**: ã‚³ã‚¢æ©Ÿèƒ½ã«é›†ä¸­ã€è¤‡é›‘ãªæ©Ÿèƒ½ã¯å¾Œå›ã—
- **è¿…é€Ÿãªãƒªãƒªãƒ¼ã‚¹**: 3-4ãƒ¶æœˆã§ã®å¸‚å ´æŠ•å…¥
- **æ®µéšçš„æ”¹å–„**: MVPç‰ˆã§ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åé›†å¾Œã€æ©Ÿèƒ½ã‚’æ®µéšçš„ã«è¿½åŠ 
- **è¨ˆæ¸¬é‡è¦–**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ•°å€¤ã¯è¨ˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…å¾Œã«æ”¹å–„

---

## ğŸš€ å…¨ä½“é–‹ç™ºãƒ•ã‚§ãƒ¼ã‚º

### MVPç‰ˆ Phase æ¦‚è¦
| Phase | æœŸé–“ | ç›®æ¨™ | é‡è¦åº¦ | æˆæœç‰© |
|-------|------|------|--------|--------|
| **Phase 1** | 4é€±é–“ | Core IELTSæ©Ÿèƒ½ | Critical | åŸºæœ¬MVPç‰ˆ |
| **Phase 2** | 4é€±é–“ | åŸºæœ¬TTSãƒ»ç°¡æ˜“åˆ†æ | High | æ©Ÿèƒ½å¼·åŒ–ç‰ˆ |
| **Phase 3** | 3é€±é–“ | æœ€å°å¾©ç¿’ãƒ»ãƒ‡ãƒ¼ã‚¿å‡ºåŠ› | Medium | ãƒªãƒªãƒ¼ã‚¹å€™è£œç‰ˆ |
| **Phase 4** | 1é€±é–“ | æœ€çµ‚èª¿æ•´ãƒ»ãƒªãƒªãƒ¼ã‚¹ | High | è£½å“ç‰ˆ |

### MVPç‰ˆç·é–‹ç™ºå·¥æ•°
- **ç·æœŸé–“**: 12é€±é–“ï¼ˆ3ãƒ¶æœˆï¼‰
- **ç·å·¥æ•°**: 450æ™‚é–“
- **å¹³å‡é€±é–“å·¥æ•°**: 38æ™‚é–“
- **é–‹ç™ºè€…**: 1åæƒ³å®š
- **å‰Šæ¸›åŠ¹æœ**: 51%ã®å·¥æ•°å‰Šæ¸›ã€40%ã®æœŸé–“çŸ­ç¸®

---

## ğŸ“… Phase 1: Core IELTSæ©Ÿèƒ½ (Week 1-4) - MVPç‰ˆç°¡ç´ åŒ–

### ğŸ¯ Phase 1 ç›®æ¨™
**IELTSç‰¹åŒ–ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç·´ç¿’ã®åŸºç›¤æ§‹ç¯‰ï¼ˆç°¡ç´ åŒ–ç‰ˆï¼‰**
- åŸºæœ¬ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½
- ç°¡ç´ åŒ–ã•ã‚ŒãŸæ¸¬å®šã‚·ã‚¹ãƒ†ãƒ 
- æœ€å°é™ã®UI/UX
- åŸºæœ¬ãƒ‡ãƒ¼ã‚¿æ°¸ç¶šåŒ–æ©Ÿèƒ½

### Week 1-2: MVPç‰ˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ»ãƒ‡ãƒ¼ã‚¿åŸºç›¤

#### Week 1: MVPç‰ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåŸºç›¤
**ç›®æ¨™**: é–‹ç™ºç’°å¢ƒã¨ã‚³ã‚¢æ§‹é€ ã®æ§‹ç¯‰
```swift
// ä½œæ¥­é …ç›®
âœ… æ–°è¦Xcodeãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
âœ… SwiftDataçµ±åˆãƒ»ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾©  
âœ… åŸºæœ¬ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å®Ÿè£…(MVVM + Repository)
âœ… ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°åŸºç›¤
```

**ä¸»è¦æˆæœç‰©ï¼ˆMVPç‰ˆç°¡ç´ åŒ–ï¼‰**:
- [ ] `IELTSApp.swift` - ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
- [ ] `Models/` ãƒ•ã‚©ãƒ«ãƒ€ - IELTSTask, TypingResultï¼ˆç°¡ç´ åŒ–ç‰ˆï¼‰
- [ ] `Repositories/` ãƒ•ã‚©ãƒ«ãƒ€ - åŸºæœ¬Repositoryå®Ÿè£…
- [ ] `ViewModels/` ãƒ•ã‚©ãƒ«ãƒ€ - ç°¡ç´ åŒ–MVVMåŸºç›¤
- [ ] `Utils/ErrorHandler.swift` - åŸºæœ¬ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

**æŠ€è¡“è©³ç´°**:
```swift
// IELTSTask.swift - ã‚³ã‚¢ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
@Model
final class IELTSTask {
    @Attribute(.unique) var id: UUID
    var taskType: TaskType
    var topic: String
    var modelAnswer: String
    var targetBandScore: Double
    var wordCount: Int
    var createdDate: Date
    
    @Relationship(deleteRule: .cascade)
    var typingResults: [TypingResult] = []
    
    init(taskType: TaskType, topic: String, modelAnswer: String, targetBandScore: Double) {
        self.id = UUID()
        self.taskType = taskType
        self.topic = topic
        self.modelAnswer = modelAnswer
        self.targetBandScore = targetBandScore
        self.wordCount = modelAnswer.count // MVPç‰ˆ: ç°¡ç´ åŒ–ï¼ˆæ–‡å­—æ•°ãƒ™ãƒ¼ã‚¹ï¼‰
        self.createdDate = Date()
    }
}

// MVPç‰ˆ TypingResult.swift - ç°¡ç´ åŒ–æ¸¬å®šçµæœãƒ¢ãƒ‡ãƒ«
@Model 
final class TypingResult {
    @Attribute(.unique) var id: UUID
    var sessionDate: Date
    var testDuration: TimeInterval
    var targetText: String
    var userInput: String
    var finalWPM: Double
    var accuracy: Double
    var completionPercentage: Double
    var basicErrorCount: Int // MVPç‰ˆ: åŸºæœ¬ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã®ã¿
    
    @Relationship(deleteRule: .nullify, inverse: \IELTSTask.typingResults)
    var task: IELTSTask?
    
    init(task: IELTSTask, userInput: String, testDuration: TimeInterval) {
        self.id = UUID()
        self.sessionDate = Date()
        self.task = task
        self.userInput = userInput
        self.testDuration = testDuration
        self.targetText = task.modelAnswer
        // MVPç‰ˆ: ç°¡ç´ åŒ–ã•ã‚ŒãŸè¨ˆç®—
        self.calculateBasicMetrics()
    }
    
    // MVPç‰ˆã§å‰Šé™¤ãƒ»å¾Œå›ã—
    // ~~qualityIndex~~ â†’ v2.0
    // ~~è©³ç´°ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹~~ â†’ v2.0
}
```

#### Week 2: MVPç‰ˆRepository Pattern & ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿
**ç›®æ¨™**: åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹å±¤ã®å®Œæˆ
```swift
// MVPç‰ˆä½œæ¥­é …ç›®
âœ… åŸºæœ¬IELTSTaskRepositoryå®Ÿè£…
âœ… åŸºæœ¬TypingResultRepositoryå®Ÿè£…
âœ… ã‚µãƒ³ãƒ—ãƒ«IELTSæ¨¡ç¯„è§£ç­”20å•ä½œæˆï¼ˆæœ€ä½é™ï¼‰
âœ… åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ä¿å­˜æ©Ÿèƒ½
// ~~è¤‡é›‘ãªãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½~~ â†’ v2.0
// ~~è©³ç´°ãªå˜ä½“ãƒ†ã‚¹ãƒˆ~~ â†’ v2.0ï¼ˆåŸºæœ¬ãƒ†ã‚¹ãƒˆã®ã¿ï¼‰
```

**æŠ€è¡“è©³ç´°**:
```swift
// IELTSTaskRepository.swift
protocol IELTSTaskRepositoryProtocol {
    func fetchAll() async throws -> [IELTSTask]
    func fetchByTaskType(_ taskType: TaskType) async throws -> [IELTSTask]
    func fetchByBandScore(_ bandScore: Double) async throws -> [IELTSTask]
    func save(_ task: IELTSTask) async throws
    func delete(id: UUID) async throws
}

class SwiftDataIELTSTaskRepository: IELTSTaskRepositoryProtocol {
    private let modelContext: ModelContext
    
    func fetchAll() async throws -> [IELTSTask] {
        let descriptor = FetchDescriptor<IELTSTask>(
            sortBy: [SortDescriptor(\.lastUsedDate, order: .reverse)]
        )
        return try modelContext.fetch(descriptor)
    }
    
    func fetchByTaskType(_ taskType: TaskType) async throws -> [IELTSTask] {
        let descriptor = FetchDescriptor<IELTSTask>(
            predicate: #Predicate { $0.taskType == taskType },
            sortBy: [SortDescriptor(\.targetBandScore)]
        )
        return try modelContext.fetch(descriptor)
    }
}
```

### Week 3-4: MVPç‰ˆã‚¿ã‚¤ãƒ”ãƒ³ã‚°æ¸¬å®šã‚¨ãƒ³ã‚¸ãƒ³

#### Week 3: MVPç‰ˆåŸºæœ¬æ¸¬å®šæ©Ÿèƒ½
**ç›®æ¨™**: ç°¡ç´ åŒ–ã•ã‚ŒãŸæ¸¬å®šã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…
```swift
// MVPç‰ˆä½œæ¥­é …ç›®
âœ… åŸºæœ¬TypingTestManagerå®Ÿè£…
âœ… åŸºæœ¬WPMè¨ˆç®—ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆç·æ–‡å­—æ•°ãƒ™ãƒ¼ã‚¹ï¼‰
âœ… åŸºæœ¬æ­£ç¢ºæ€§è¨ˆç®—ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
âœ… 2åˆ†ã‚¿ã‚¤ãƒãƒ¼æ©Ÿèƒ½
// ~~å“è³ªæŒ‡æ•°è¨ˆç®—~~ â†’ v2.0
// ~~ç¬é–“WPMã€å¹³å‡WPM~~ â†’ v2.0
```

**æŠ€è¡“è©³ç´°**:
```swift
// TypingTestManager.swift
@MainActor
@Observable
final class TypingTestManager {
    // æ¸¬å®šçŠ¶æ…‹
    private(set) var isActive: Bool = false
    private(set) var remainingTime: TimeInterval = 120 // 2åˆ†
    private(set) var currentWPM: Double = 0
    private(set) var accuracy: Double = 100
    private(set) var qualityIndex: Double = 0
    private(set) var completionPercentage: Double = 0
    
    // å†…éƒ¨çŠ¶æ…‹
    private var startTime: Date?
    private var timer: Timer?
    private var currentTask: IELTSTask?
    private var targetText: String = ""
    private var userInput: String = ""
    
    // MVPç‰ˆè¨­å®šï¼ˆç·©å’Œï¼‰
    private let timeLimit: TimeInterval = 120
    private let updateInterval: TimeInterval = 0.2 // 200msæ›´æ–°ï¼ˆ100msâ†’200msã«ç·©å’Œï¼‰
    
    func startTest(with task: IELTSTask) {
        self.currentTask = task
        self.targetText = task.modelAnswer
        self.startTime = Date()
        self.isActive = true
        self.remainingTime = timeLimit
        
        resetMetrics()
        startTimer()
    }
    
    func updateInput(_ input: String) {
        guard isActive else { return }
        self.userInput = input
        calculateMetrics()
    }
    
    func endTest() -> TypingResult? {
        guard let task = currentTask, let startTime = startTime else { return nil }
        
        isActive = false
        timer?.invalidate()
        
        let testDuration = Date().timeIntervalSince(startTime)
        let result = TypingResult(
            task: task,
            testDuration: testDuration,
            finalWPM: currentWPM,
            accuracy: accuracy
        )
        
        return result
    }
    
    private func calculateMetrics() {
        guard let startTime = startTime else { return }
        
        let elapsedTime = Date().timeIntervalSince(startTime)
        let minutes = elapsedTime / 60.0
        
        // MVPç‰ˆ: åŸºæœ¬WPMè¨ˆç®—ï¼ˆç·æ–‡å­—æ•°ãƒ™ãƒ¼ã‚¹ï¼‰
        let totalChars = Double(userInput.count)
        currentWPM = minutes > 0 ? (totalChars / 5.0) / minutes : 0
        
        // MVPç‰ˆ: åŸºæœ¬æ­£ç¢ºæ€§è¨ˆç®—
        let correctChars = Double(calculateCorrectCharacters())
        accuracy = totalChars > 0 ? (correctChars / totalChars) * 100 : 100
        
        // ~~å“è³ªæŒ‡æ•°: å‰Šé™¤~~ â†’ v2.0
        
        // å®Œäº†ç‡
        let targetLength = Double(targetText.count)
        completionPercentage = targetLength > 0 ? (totalChars / targetLength) * 100 : 0
    }
    
    private func calculateCorrectCharacters() -> Int {
        let target = Array(targetText)
        let input = Array(userInput)
        var correctCount = 0
        
        for (index, char) in input.enumerated() {
            if index < target.count && char == target[index] {
                correctCount += 1
            }
        }
        
        return correctCount
    }
    
    private func startTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: updateInterval, repeats: true) { [weak self] _ in
            self?.updateTimer()
        }
    }
    
    private func updateTimer() {
        guard let startTime = startTime else { return }
        
        let elapsed = Date().timeIntervalSince(startTime)
        remainingTime = max(0, timeLimit - elapsed)
        
        if remainingTime <= 0 {
            _ = endTest()
        }
    }
    
    private func resetMetrics() {
        currentWPM = 0
        accuracy = 100
        qualityIndex = 0
        completionPercentage = 0
        userInput = ""
    }
}
```

#### Week 4: MVPç‰ˆåŸºæœ¬æœ€é©åŒ–
**ç›®æ¨™**: å®Ÿç”¨çš„ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ç¢ºä¿
```swift
// MVPç‰ˆä½œæ¥­é …ç›®
âœ… åŸºæœ¬çš„ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç¢ºä¿
âœ… åŸºæœ¬ãƒ¡ãƒ¢ãƒªç®¡ç†
âœ… ç°¡ç´ åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£…
âœ… åŸºæœ¬ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
// ~~é«˜åº¦ãªæœ€é©åŒ–~~ â†’ v2.0
// ~~è©³ç´°ãªã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ~~ â†’ v2.0
```

**MVPç‰ˆåŸºæœ¬ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–**:
```swift
// MVPç‰ˆ: åŸºæœ¬çš„ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬ã®ã¿
struct BasicPerformanceMonitor {
    static let shared = BasicPerformanceMonitor()
    
    func measureExecutionTime<T>(_ operation: () throws -> T) rethrows -> (result: T, timeMs: Double) {
        let startTime = CFAbsoluteTimeGetCurrent()
        let result = try operation()
        let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
        return (result: result, timeMs: timeElapsed * 1000)
    }
    
    func logPerformance(_ metric: String, value: Double, unit: String = "ms") {
        print("Performance: \(metric) = \(value)\(unit)")
    }
}

// MVPç‰ˆã§å‰Šé™¤ãƒ»å¾Œå›ã—
// ~~é«˜åº¦ãªå…¥åŠ›ãƒ‡ãƒã‚¦ãƒ³ã‚¹~~ â†’ v2.0
// ~~è¤‡é›‘ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–~~ â†’ v2.0
```

### Week 5-6: ãƒ¡ã‚¤ãƒ³UIå®Ÿè£…

#### Week 5: ç·´ç¿’ç”»é¢Layout
**ç›®æ¨™**: IELTSç‰¹åŒ–UIã®åŸºæœ¬æ§‹æˆ
```swift
// ä½œæ¥­é …ç›®
âœ… TypingPracticeViewå®Ÿè£… - ãƒ¡ã‚¤ãƒ³ç·´ç¿’ç”»é¢
âœ… å·¦å´: TargetTextPanel - æ¨¡ç¯„è§£ç­”è¡¨ç¤º
âœ… å³å´: InputArea - ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚¨ãƒªã‚¢
âœ… ä¸‹éƒ¨: StatisticsPanel - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çµ±è¨ˆ
âœ… ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¯¾å¿œ
```

**UIå®Ÿè£…è©³ç´°**:
```swift
// TypingPracticeView.swift - ãƒ¡ã‚¤ãƒ³ç·´ç¿’ç”»é¢
struct TypingPracticeView: View {
    @StateObject private var testManager = TypingTestManager()
    @State private var currentTask: IELTSTask?
    @State private var userInput: String = ""
    
    var body: some View {
        VStack(spacing: 16) {
            // ãƒ˜ãƒƒãƒ€ãƒ¼
            HeaderView(
                taskTitle: currentTask?.topic ?? "IELTS Practice",
                remainingTime: testManager.remainingTime,
                isActive: testManager.isActive
            )
            
            // ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢
            HStack(spacing: 16) {
                // å·¦å´: ç›®æ¨™æ–‡è¡¨ç¤º
                TargetTextPanel(
                    text: currentTask?.modelAnswer ?? "",
                    wordCount: currentTask?.wordCount ?? 0,
                    bandScore: currentTask?.targetBandScore ?? 0
                )
                .frame(minWidth: 400)
                
                // å³å´: å…¥åŠ›ã‚¨ãƒªã‚¢
                InputArea(
                    input: $userInput,
                    isActive: testManager.isActive,
                    onInputChange: { input in
                        testManager.updateInput(input)
                    }
                )
                .frame(minWidth: 400)
            }
            
            // ä¸‹éƒ¨: çµ±è¨ˆãƒ‘ãƒãƒ«
            StatisticsPanel(
                wpm: testManager.currentWPM,
                accuracy: testManager.accuracy,
                qualityIndex: testManager.qualityIndex,
                completionPercentage: testManager.completionPercentage
            )
            
            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³
            ControlButtonsView(
                isActive: testManager.isActive,
                onStart: startTest,
                onPause: testManager.pauseTest,
                onEnd: endTest
            )
        }
        .padding()
        .onAppear(perform: loadTasks)
    }
    
    private func startTest() {
        guard let task = currentTask else { return }
        testManager.startTest(with: task)
    }
    
    private func endTest() {
        guard let result = testManager.endTest() else { return }
        // çµæœä¿å­˜å‡¦ç†
    }
}

// TargetTextPanel.swift - ç›®æ¨™æ–‡è¡¨ç¤ºãƒ‘ãƒãƒ«
struct TargetTextPanel: View {
    let text: String
    let wordCount: Int
    let bandScore: Double
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // ãƒ˜ãƒƒãƒ€ãƒ¼
            HStack {
                Text("Target Text (\(wordCount) words)")
                    .font(.headline)
                    .foregroundColor(.primary)
                
                Spacer()
                
                Text("Band Score: \(String(format: "%.1f", bandScore))")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(8)
            }
            
            Divider()
            
            // ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
            ScrollView {
                Text(text)
                    .font(.body)
                    .lineSpacing(4)
                    .multilineTextAlignment(.leading)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding()
                    .background(Color(NSColor.textBackgroundColor))
                    .cornerRadius(8)
            }
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(12)
    }
}

// InputArea.swift - å…¥åŠ›ã‚¨ãƒªã‚¢
struct InputArea: View {
    @Binding var input: String
    let isActive: Bool
    let onInputChange: (String) -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // ãƒ˜ãƒƒãƒ€ãƒ¼
            HStack {
                Text("Your Input")
                    .font(.headline)
                
                Spacer()
                
                Text("\(input.wordCount)/250 words")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            Divider()
            
            // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼
            TextEditor(text: $input)
                .font(.body)
                .lineSpacing(4)
                .disabled(!isActive)
                .background(Color(NSColor.textBackgroundColor))
                .cornerRadius(8)
                .onChange(of: input) { _, newValue in
                    onInputChange(newValue)
                }
            
            // çµ±è¨ˆæƒ…å ±
            HStack {
                Text("Characters: \(input.count)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Text("Sentences: \(input.sentenceCount)")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(12)
    }
}

// StatisticsPanel.swift - çµ±è¨ˆãƒ‘ãƒãƒ«
struct StatisticsPanel: View {
    let wpm: Double
    let accuracy: Double
    let qualityIndex: Double
    let completionPercentage: Double
    
    var body: some View {
        HStack(spacing: 20) {
            StatCard(
                title: "WPM",
                value: String(format: "%.0f", wpm),
                color: .blue,
                icon: "speedometer"
            )
            
            StatCard(
                title: "Accuracy",
                value: String(format: "%.1f%%", accuracy),
                color: .green,
                icon: "target"
            )
            
            StatCard(
                title: "Quality",
                value: String(format: "%.2f", qualityIndex),
                color: .purple,
                icon: "trophy"
            )
            
            StatCard(
                title: "Progress",
                value: String(format: "%.0f%%", completionPercentage),
                color: .orange,
                icon: "chart.line.uptrend.xyaxis"
            )
        }
        .padding(.vertical, 12)
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
    }
}

// StatCard.swift - çµ±è¨ˆã‚«ãƒ¼ãƒ‰
struct StatCard: View {
    let title: String
    let value: String
    let color: Color
    let icon: String
    
    var body: some View {
        VStack(spacing: 8) {
            HStack(spacing: 4) {
                Image(systemName: icon)
                    .foregroundColor(color)
                    .font(.title3)
                
                Text(title)
                    .font(.caption)
                    .fontWeight(.medium)
                    .foregroundColor(.secondary)
            }
            
            Text(value)
                .font(.title2)
                .fontWeight(.semibold)
                .foregroundColor(.primary)
        }
        .frame(minWidth: 80)
        .padding(.vertical, 8)
    }
}
```

#### Week 6: UIæ”¹å–„ãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ
**ç›®æ¨™**: ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š
```swift
// ä½œæ¥­é …ç›®
âœ… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…
âœ… ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
âœ… ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å¯¾å¿œ
âœ… ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
âœ… ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ
```

### Week 7-8: åŸºæœ¬çµ±åˆãƒ»ãƒ†ã‚¹ãƒˆ

#### Week 7: ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰çµ±åˆ
**ç›®æ¨™**: å®Œå…¨ãªç·´ç¿’ãƒ•ãƒ­ãƒ¼å®Ÿç¾
```swift
// ä½œæ¥­é …ç›®
âœ… ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼çµ±åˆãƒ†ã‚¹ãƒˆ
âœ… UI/UXãƒ•ãƒ­ãƒ¼æ¤œè¨¼
âœ… ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹å‡¦ç†
âœ… ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¤œè¨¼
âœ… ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œè¨¼
```

#### Week 8: Phase 1 å®Œæˆãƒ»æ¤œè¨¼
**ç›®æ¨™**: MVPç‰ˆã®å®Œæˆ
```swift
// ä½œæ¥­é …ç›®
âœ… ç·åˆãƒ†ã‚¹ãƒˆå®Ÿæ–½
âœ… ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€çµ‚èª¿æ•´
âœ… ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆ
âœ… Phase 2 æº–å‚™
âœ… ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
```

**Phase 1 MVPç‰ˆå®ŒæˆåŸºæº–**:
- [ ] 2åˆ†ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ†ã‚¹ãƒˆåŸºæœ¬å‹•ä½œ
- [ ] WPMãƒ»AccuracyåŸºæœ¬è¨ˆæ¸¬ï¼ˆQuality Indexã¯å‰Šé™¤ï¼‰
- [ ] å®Ÿç”¨çš„ãªå…¥åŠ›å¿œç­”æ€§ï¼ˆæ•°å€¤ã¯è¨ˆæ¸¬å¾Œæ”¹å–„ï¼‰
- [ ] 20å•ä»¥ä¸Šã®IELTSæ¨¡ç¯„è§£ç­”
- [ ] åŸºæœ¬ãƒ‡ãƒ¼ã‚¿æ°¸ç¶šåŒ–å‹•ä½œ

---

## ğŸ“… Phase 2: åŸºæœ¬TTSãƒ»ç°¡æ˜“åˆ†æ (Week 5-8) - MVPç‰ˆç°¡ç´ åŒ–

### ğŸ¯ Phase 2 ç›®æ¨™
**åŸºæœ¬å­¦ç¿’æ”¯æ´æ©Ÿèƒ½ã®å®Ÿè£…ï¼ˆç°¡ç´ åŒ–ç‰ˆï¼‰**
- åŸºæœ¬TTSéŸ³å£°ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå…¨æ–‡å†ç”Ÿã®ã¿ï¼‰
- åŸºæœ¬ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆæ©Ÿèƒ½
- 3è‰²åŸºæœ¬å·®åˆ†è¡¨ç¤º
- åŸºæœ¬ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬

### Week 5-6: MVPç‰ˆåŸºæœ¬TTSã‚·ã‚¹ãƒ†ãƒ 

#### Week 5: MVPç‰ˆAVFoundationçµ±åˆ
**ç›®æ¨™**: åŸºæœ¬éŸ³å£°æ©Ÿèƒ½å®Ÿè£…ï¼ˆç°¡ç´ åŒ–ï¼‰
```swift
// MVPç‰ˆä½œæ¥­é …ç›®
âœ… BasicTTSManagerå®Ÿè£…
âœ… AVSpeechSynthesizerçµ±åˆ
âœ… å…¨æ–‡å†ç”Ÿæ©Ÿèƒ½ã®ã¿ï¼ˆæ–‡ãƒ»ãƒ•ãƒ¬ãƒ¼ã‚ºå†ç”Ÿã¯å‰Šé™¤ï¼‰
âœ… 3æ®µéšé€Ÿåº¦èª¿æ•´ï¼ˆç°¡ç´ åŒ–ï¼‰
âœ… US Englishå›ºå®šï¼ˆè¨€èªé¸æŠå‰Šé™¤ï¼‰
âœ… åŸºæœ¬ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
// ~~è©³ç´°éŸ³å£°å“è³ªæœ€é©åŒ–~~ â†’ v2.0
```

**æŠ€è¡“å®Ÿè£…è©³ç´°**:
```swift
// TTSManager.swift - éŸ³å£°åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ 
@MainActor
@Observable
final class TTSManager: NSObject, AVSpeechSynthesizerDelegate {
    private let synthesizer = AVSpeechSynthesizer()
    
    // çŠ¶æ…‹ç®¡ç†
    private(set) var isPlaying: Bool = false
    private(set) var isPaused: Bool = false
    private(set) var currentPosition: TimeInterval = 0
    private(set) var totalDuration: TimeInterval = 0
    
    // è¨­å®š
    var playbackSpeed: Float = 1.0 {
        didSet { updateSettings() }
    }
    var voiceLanguage: VoiceLanguage = .usEnglish {
        didSet { updateVoice() }
    }
    var playbackMode: PlaybackMode = .full
    
    // å†…éƒ¨çŠ¶æ…‹
    private var currentUtterance: AVSpeechUtterance?
    private var currentText: String = ""
    private var sentences: [String] = []
    private var currentSentenceIndex: Int = 0
    
    override init() {
        super.init()
        synthesizer.delegate = self
        updateVoice()
    }
    
    // MARK: - Public Methods
    
    func playFullText(_ text: String) {
        stop()
        currentText = text
        playbackMode = .full
        
        let utterance = createUtterance(from: text)
        speak(utterance)
        
        AppLogger.shared.logTTSEvent("play_full_text", duration: estimateDuration(text))
    }
    
    func playSentence(_ text: String, at index: Int = 0) {
        stop()
        currentText = text
        playbackMode = .sentence
        
        // æ–‡ã«åˆ†å‰²
        sentences = text.components(separatedBy: .sentenceTerminators)
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            .filter { !$0.isEmpty }
        
        guard index < sentences.count else { return }
        currentSentenceIndex = index
        
        let utterance = createUtterance(from: sentences[index])
        speak(utterance)
        
        AppLogger.shared.logTTSEvent("play_sentence", duration: estimateDuration(sentences[index]))
    }
    
    func playPhrase(_ phrase: String) {
        stop()
        currentText = phrase
        playbackMode = .phrase
        
        let utterance = createUtterance(from: phrase)
        speak(utterance)
        
        AppLogger.shared.logTTSEvent("play_phrase", duration: estimateDuration(phrase))
    }
    
    func pause() {
        guard isPlaying else { return }
        synthesizer.pauseSpeaking(at: .immediate)
        isPaused = true
        isPlaying = false
    }
    
    func resume() {
        guard isPaused else { return }
        synthesizer.continueSpeaking()
        isPaused = false
        isPlaying = true
    }
    
    func stop() {
        synthesizer.stopSpeaking(at: .immediate)
        isPlaying = false
        isPaused = false
        currentPosition = 0
        currentUtterance = nil
    }
    
    func setSpeed(_ speed: Float) {
        playbackSpeed = max(0.5, min(2.0, speed))
    }
    
    func setVoiceLanguage(_ language: VoiceLanguage) {
        voiceLanguage = language
        updateVoice()
    }
    
    // MARK: - Private Methods
    
    private func createUtterance(from text: String) -> AVSpeechUtterance {
        let utterance = AVSpeechUtterance(string: text)
        utterance.rate = AVSpeechUtteranceDefaultSpeechRate * playbackSpeed
        utterance.voice = getVoice(for: voiceLanguage)
        utterance.volume = 1.0
        utterance.pitchMultiplier = 1.0
        return utterance
    }
    
    private func speak(_ utterance: AVSpeechUtterance) {
        currentUtterance = utterance
        synthesizer.speak(utterance)
        isPlaying = true
        isPaused = false
    }
    
    private func updateSettings() {
        if isPlaying, let utterance = currentUtterance {
            utterance.rate = AVSpeechUtteranceDefaultSpeechRate * playbackSpeed
        }
    }
    
    private func updateVoice() {
        if isPlaying, let utterance = currentUtterance {
            utterance.voice = getVoice(for: voiceLanguage)
        }
    }
    
    private func getVoice(for language: VoiceLanguage) -> AVSpeechSynthesisVoice? {
        switch language {
        case .usEnglish:
            return AVSpeechSynthesisVoice(language: "en-US")
        case .ukEnglish:
            return AVSpeechSynthesisVoice(language: "en-GB")
        }
    }
    
    private func estimateDuration(_ text: String) -> TimeInterval {
        // æ¨å®š: é€šå¸¸é€Ÿåº¦ã§150èª/åˆ†
        let wordsPerMinute = 150.0 * Double(playbackSpeed)
        let wordCount = Double(text.wordCount)
        return (wordCount / wordsPerMinute) * 60.0
    }
    
    // MARK: - AVSpeechSynthesizerDelegate
    
    nonisolated func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didStart utterance: AVSpeechUtterance) {
        Task { @MainActor in
            isPlaying = true
            isPaused = false
        }
    }
    
    nonisolated func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {
        Task { @MainActor in
            isPlaying = false
            isPaused = false
            currentPosition = 0
            
            // æ–‡ãƒ¢ãƒ¼ãƒ‰ã§æ¬¡ã®æ–‡ã‚’è‡ªå‹•å†ç”Ÿ
            if playbackMode == .sentence && currentSentenceIndex < sentences.count - 1 {
                playNextSentence()
            }
        }
    }
    
    private func playNextSentence() {
        currentSentenceIndex += 1
        let utterance = createUtterance(from: sentences[currentSentenceIndex])
        speak(utterance)
    }
}

// VoiceLanguage.swift - éŸ³å£°è¨€èªå®šç¾©
enum VoiceLanguage: String, CaseIterable {
    case usEnglish = "en-US"
    case ukEnglish = "en-GB"
    
    var displayName: String {
        switch self {
        case .usEnglish: return "US English"
        case .ukEnglish: return "UK English"
        }
    }
    
    var flag: String {
        switch self {
        case .usEnglish: return "ğŸ‡ºğŸ‡¸"
        case .ukEnglish: return "ğŸ‡¬ğŸ‡§"
        }
    }
}

enum PlaybackMode: String, CaseIterable {
    case full = "full"
    case sentence = "sentence"
    case phrase = "phrase"
    
    var displayName: String {
        switch self {
        case .full: return "Full Text"
        case .sentence: return "Sentence by Sentence"
        case .phrase: return "Selected Phrase"
        }
    }
}
```

#### Week 6: MVPç‰ˆTTSåˆ¶å¾¡UIå®Ÿè£…
**ç›®æ¨™**: ç°¡ç´ åŒ–éŸ³å£°åˆ¶å¾¡ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
```swift
// MVPç‰ˆä½œæ¥­é …ç›®
âœ… BasicTTSControlView UIå®Ÿè£…
âœ… åŸºæœ¬åˆ¶å¾¡ãƒœã‚¿ãƒ³(å†ç”Ÿ/åœæ­¢/ä¸€æ™‚åœæ­¢)
âœ… 3æ®µéšé€Ÿåº¦é¸æŠãƒœã‚¿ãƒ³ï¼ˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼å‰Šé™¤ï¼‰
// ~~éŸ³å£°è¨€èªé¸æŠ~~ â†’ v2.0ï¼ˆUS Englishå›ºå®šï¼‰
// ~~å†ç”Ÿãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ~~ â†’ v2.0ï¼ˆå…¨æ–‡å†ç”Ÿã®ã¿ï¼‰
```

**UIå®Ÿè£…è©³ç´°**:
```swift
// TTSControlPanel.swift - éŸ³å£°åˆ¶å¾¡ãƒ‘ãƒãƒ«
struct TTSControlPanel: View {
    @StateObject private var ttsManager = TTSManager()
    @State private var selectedText: String = ""
    
    var body: some View {
        VStack(spacing: 16) {
            // ãƒ¡ã‚¤ãƒ³åˆ¶å¾¡ãƒœã‚¿ãƒ³
            HStack(spacing: 12) {
                Button(action: { ttsManager.playFullText(selectedText) }) {
                    Label("Play All", systemImage: "play.fill")
                        .foregroundColor(.white)
                        .padding(.horizontal, 16)
                        .padding(.vertical, 8)
                        .background(Color.blue)
                        .cornerRadius(8)
                }
                .disabled(ttsManager.isPlaying)
                
                Button(action: ttsManager.pause) {
                    Image(systemName: "pause.fill")
                        .foregroundColor(.orange)
                        .font(.title2)
                }
                .disabled(!ttsManager.isPlaying)
                
                Button(action: ttsManager.resume) {
                    Image(systemName: "play.fill")
                        .foregroundColor(.green)
                        .font(.title2)
                }
                .disabled(!ttsManager.isPaused)
                
                Button(action: ttsManager.stop) {
                    Image(systemName: "stop.fill")
                        .foregroundColor(.red)
                        .font(.title2)
                }
                .disabled(!ttsManager.isPlaying && !ttsManager.isPaused)
            }
            
            // è¨­å®šã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            VStack(spacing: 12) {
                // å†ç”Ÿé€Ÿåº¦
                HStack {
                    Text("Speed:")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    Slider(
                        value: Binding(
                            get: { ttsManager.playbackSpeed },
                            set: { ttsManager.setSpeed($0) }
                        ),
                        in: 0.5...2.0,
                        step: 0.25
                    )
                    .frame(width: 120)
                    
                    Text("\(String(format: "%.1fx", ttsManager.playbackSpeed))")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .frame(width: 35)
                }
                
                // éŸ³å£°è¨€èªé¸æŠ
                HStack {
                    Text("Voice:")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    Picker("Voice Language", selection: Binding(
                        get: { ttsManager.voiceLanguage },
                        set: { ttsManager.setVoiceLanguage($0) }
                    )) {
                        ForEach(VoiceLanguage.allCases, id: \.self) { voice in
                            Text("\(voice.flag) \(voice.displayName)")
                                .tag(voice)
                        }
                    }
                    .pickerStyle(.menu)
                    .frame(width: 150)
                }
                
                // å†ç”Ÿãƒ¢ãƒ¼ãƒ‰
                HStack {
                    Text("Mode:")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    Picker("Playback Mode", selection: $ttsManager.playbackMode) {
                        ForEach(PlaybackMode.allCases, id: \.self) { mode in
                            Text(mode.displayName).tag(mode)
                        }
                    }
                    .pickerStyle(.segmented)
                    .frame(width: 200)
                }
            }
            
            // å†ç”ŸçŠ¶æ…‹è¡¨ç¤º
            if ttsManager.isPlaying || ttsManager.isPaused {
                HStack {
                    Text(ttsManager.isPlaying ? "Playing..." : "Paused")
                        .font(.caption)
                        .foregroundColor(.blue)
                    
                    Spacer()
                    
                    if ttsManager.isPlaying {
                        ProgressView()
                            .scaleEffect(0.7)
                    }
                }
            }
        }
        .padding(16)
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(12)
    }
}
```

### Week 7-8: MVPç‰ˆåŸºæœ¬ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼

#### Week 7: MVPç‰ˆBasicErrorCounterå®Ÿè£…
**ç›®æ¨™**: åŸºæœ¬ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆæ©Ÿèƒ½
```swift
// MVPç‰ˆä½œæ¥­é …ç›®
âœ… BasicErrorCounteræ§‹é€ å®Ÿè£…
âœ… ç°¡å˜ãªæ–‡å­—æ¯”è¼ƒã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
âœ… åŸºæœ¬é–“é•ã„ã‚«ã‚¦ãƒ³ãƒˆæ©Ÿèƒ½
âœ… ã‚¨ãƒ©ãƒ¼ç‡è¨ˆç®—
// ~~8ç¨®é¡ã‚¨ãƒ£ãƒ¼åˆ†é¡~~ â†’ v2.0
// ~~è©³ç´°ã‚¹ãƒšãƒ«ãƒã‚§ãƒƒã‚¯~~ â†’ v2.0
// ~~æ–‡æ³•åˆ†æ~~ â†’ v2.0
```

**å®Ÿè£…è©³ç´°**:
```swift
// ErrorAnalyzer.swift - ã‚¨ãƒ©ãƒ¼åˆ†æã‚¨ãƒ³ã‚¸ãƒ³
struct ErrorAnalyzer {
    private let spellChecker = NSSpellChecker()
    
    func analyzeText(_ input: String, target: String) -> [ErrorResult] {
        var errors: [ErrorResult] = []
        
        // 1. åŸºæœ¬å·®åˆ†è§£æ
        let basicErrors = findBasicDifferences(input: input, target: target)
        errors.append(contentsOf: basicErrors)
        
        // 2. ã‚¹ãƒšãƒ«ãƒã‚§ãƒƒã‚¯
        let spellingErrors = analyzeSpelling(input)
        errors.append(contentsOf: spellingErrors)
        
        // 3. å¥èª­ç‚¹åˆ†æ
        let punctuationErrors = analyzePunctuation(input: input, target: target)
        errors.append(contentsOf: punctuationErrors)
        
        // 4. å¤§æ–‡å­—åŒ–åˆ†æ
        let capitalizationErrors = analyzeCapitalization(input: input, target: target)
        errors.append(contentsOf: capitalizationErrors)
        
        // 5. æ–‡æ³•åˆ†æ(åŸºæœ¬)
        let grammarErrors = analyzeBasicGrammar(input: input, target: target)
        errors.append(contentsOf: grammarErrors)
        
        // é‡è¤‡é™¤å»ãƒ»ä½ç½®ã‚½ãƒ¼ãƒˆ
        return removeDuplicates(errors).sorted { $0.position < $1.position }
    }
    
    // MARK: - Basic Difference Analysis
    
    private func findBasicDifferences(input: String, target: String) -> [ErrorResult] {
        var errors: [ErrorResult] = []
        let inputChars = Array(input)
        let targetChars = Array(target)
        
        let maxLength = max(inputChars.count, targetChars.count)
        
        for i in 0..<maxLength {
            if i >= inputChars.count {
                // æœªå…¥åŠ›æ–‡å­—
                let error = ErrorResult(
                    type: .spelling,
                    position: i,
                    expected: String(targetChars[i]),
                    actual: "",
                    suggestion: "Add missing character: '\(targetChars[i])'"
                )
                errors.append(error)
            } else if i >= targetChars.count {
                // ä½™åˆ†ãªæ–‡å­—
                let error = ErrorResult(
                    type: .spelling,
                    position: i,
                    expected: "",
                    actual: String(inputChars[i]),
                    suggestion: "Remove extra character: '\(inputChars[i])'"
                )
                errors.append(error)
            } else if inputChars[i] != targetChars[i] {
                // ç•°ãªã‚‹æ–‡å­—
                let error = ErrorResult(
                    type: .spelling,
                    position: i,
                    expected: String(targetChars[i]),
                    actual: String(inputChars[i]),
                    suggestion: "Change '\(inputChars[i])' to '\(targetChars[i])'"
                )
                errors.append(error)
            }
        }
        
        return errors
    }
    
    // MARK: - Spelling Analysis
    
    private func analyzeSpelling(_ text: String) -> [ErrorResult] {
        var errors: [ErrorResult] = []
        let range = NSRange(location: 0, length: text.count)
        
        var currentRange = range
        while currentRange.length > 0 {
            let misspelledRange = spellChecker.rangeOfMisspelledWord(
                in: text,
                range: currentRange,
                startingAt: currentRange.location,
                wrap: false,
                language: "en"
            )
            
            if misspelledRange.location == NSNotFound {
                break
            }
            
            let misspelledWord = (text as NSString).substring(with: misspelledRange)
            let suggestions = spellChecker.guesses(
                forWordRange: misspelledRange,
                in: text,
                language: "en",
                inSpellDocumentWithTag: 0
            )
            
            let error = ErrorResult(
                type: .spelling,
                position: misspelledRange.location,
                expected: suggestions?.first ?? misspelledWord,
                actual: misspelledWord,
                suggestion: suggestions?.first != nil ? 
                    "Did you mean '\(suggestions!.first!)'?" : 
                    "Check spelling of '\(misspelledWord)'"
            )
            errors.append(error)
            
            currentRange = NSRange(
                location: misspelledRange.location + misspelledRange.length,
                length: range.length - (misspelledRange.location + misspelledRange.length)
            )
        }
        
        return errors
    }
    
    // MARK: - Punctuation Analysis
    
    private func analyzePunctuation(input: String, target: String) -> [ErrorResult] {
        var errors: [ErrorResult] = []
        
        let inputPunctuation = extractPunctuationWithPositions(from: input)
        let targetPunctuation = extractPunctuationWithPositions(from: target)
        
        let maxCount = max(inputPunctuation.count, targetPunctuation.count)
        
        for i in 0..<maxCount {
            if i >= inputPunctuation.count {
                // å¥èª­ç‚¹ä¸è¶³
                let targetPunct = targetPunctuation[i]
                let error = ErrorResult(
                    type: .punctuation,
                    position: targetPunct.position,
                    expected: String(targetPunct.character),
                    actual: "",
                    suggestion: "Add missing punctuation: '\(targetPunct.character)'"
                )
                errors.append(error)
            } else if i >= targetPunctuation.count {
                // ä½™åˆ†ãªå¥èª­ç‚¹
                let inputPunct = inputPunctuation[i]
                let error = ErrorResult(
                    type: .punctuation,
                    position: inputPunct.position,
                    expected: "",
                    actual: String(inputPunct.character),
                    suggestion: "Remove extra punctuation: '\(inputPunct.character)'"
                )
                errors.append(error)
            } else if inputPunctuation[i].character != targetPunctuation[i].character {
                // ç•°ãªã‚‹å¥èª­ç‚¹
                let inputPunct = inputPunctuation[i]
                let targetPunct = targetPunctuation[i]
                let error = ErrorResult(
                    type: .punctuation,
                    position: inputPunct.position,
                    expected: String(targetPunct.character),
                    actual: String(inputPunct.character),
                    suggestion: "Change '\(inputPunct.character)' to '\(targetPunct.character)'"
                )
                errors.append(error)
            }
        }
        
        return errors
    }
    
    // MARK: - Capitalization Analysis
    
    private func analyzeCapitalization(input: String, target: String) -> [ErrorResult] {
        var errors: [ErrorResult] = []
        
        let inputChars = Array(input)
        let targetChars = Array(target)
        
        for (index, targetChar) in targetChars.enumerated() {
            if index < inputChars.count {
                let inputChar = inputChars[index]
                
                if targetChar.isUppercase && inputChar.isLowercase {
                    // å¤§æ–‡å­—ã§ã‚ã‚‹ã¹ã
                    let error = ErrorResult(
                        type: .capitalization,
                        position: index,
                        expected: String(targetChar),
                        actual: String(inputChar),
                        suggestion: "Capitalize '\(inputChar)' to '\(targetChar)'"
                    )
                    errors.append(error)
                } else if targetChar.isLowercase && inputChar.isUppercase {
                    // å°æ–‡å­—ã§ã‚ã‚‹ã¹ã
                    let error = ErrorResult(
                        type: .capitalization,
                        position: index,
                        expected: String(targetChar),
                        actual: String(inputChar),
                        suggestion: "Make '\(inputChar)' lowercase: '\(targetChar)'"
                    )
                    errors.append(error)
                }
            }
        }
        
        return errors
    }
    
    // MARK: - Basic Grammar Analysis
    
    private func analyzeBasicGrammar(input: String, target: String) -> [ErrorResult] {
        var errors: [ErrorResult] = []
        
        // å† è©åˆ†æ
        errors.append(contentsOf: analyzeArticles(input: input, target: target))
        
        // ä¸‰å˜ç¾åˆ†æ
        errors.append(contentsOf: analyzeThirdPerson(input: input, target: target))
        
        // è¤‡æ•°å½¢åˆ†æ
        errors.append(contentsOf: analyzePlurals(input: input, target: target))
        
        return errors
    }
    
    private func analyzeArticles(input: String, target: String) -> [ErrorResult] {
        // ç°¡æ˜“çš„ãªå† è©åˆ†æå®Ÿè£…
        // å®Ÿéš›ã«ã¯è‡ªç„¶è¨€èªå‡¦ç†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒæ¨å¥¨
        var errors: [ErrorResult] = []
        
        let articles = ["a", "an", "the"]
        let inputWords = input.lowercased().components(separatedBy: .whitespacesAndNewlines)
        let targetWords = target.lowercased().components(separatedBy: .whitespacesAndNewlines)
        
        for (index, targetWord) in targetWords.enumerated() {
            if articles.contains(targetWord) {
                if index < inputWords.count {
                    let inputWord = inputWords[index]
                    if inputWord != targetWord {
                        let error = ErrorResult(
                            type: .article,
                            position: findWordPosition(targetWord, in: target, wordIndex: index),
                            expected: targetWord,
                            actual: inputWord,
                            suggestion: articles.contains(inputWord) ? 
                                "Use '\(targetWord)' instead of '\(inputWord)'" :
                                "Add article '\(targetWord)'"
                        )
                        errors.append(error)
                    }
                } else {
                    // å† è©ä¸è¶³
                    let error = ErrorResult(
                        type: .article,
                        position: input.count,
                        expected: targetWord,
                        actual: "",
                        suggestion: "Add missing article '\(targetWord)'"
                    )
                    errors.append(error)
                }
            }
        }
        
        return errors
    }
    
    // MARK: - Helper Methods
    
    private func extractPunctuationWithPositions(from text: String) -> [(character: Character, position: Int)] {
        var punctuation: [(Character, Int)] = []
        
        for (index, char) in text.enumerated() {
            if char.isPunctuation {
                punctuation.append((char, index))
            }
        }
        
        return punctuation
    }
    
    private func findWordPosition(_ word: String, in text: String, wordIndex: Int) -> Int {
        let words = text.components(separatedBy: .whitespacesAndNewlines)
        var position = 0
        
        for i in 0..<min(wordIndex, words.count) {
            position += words[i].count + 1 // +1 for space
        }
        
        return position
    }
    
    private func removeDuplicates(_ errors: [ErrorResult]) -> [ErrorResult] {
        var seen: Set<String> = []
        return errors.filter { error in
            let key = "\(error.position)-\(error.type.rawValue)"
            return seen.insert(key).inserted
        }
    }
    
    private func analyzeThirdPerson(input: String, target: String) -> [ErrorResult] {
        // ä¸‰å˜ç¾ã®'s'åˆ†æå®Ÿè£…
        // ç°¡æ˜“ç‰ˆå®Ÿè£… - å®Ÿéš›ã«ã¯ã‚ˆã‚Šé«˜åº¦ãªè‡ªç„¶è¨€èªå‡¦ç†ãŒå¿…è¦
        return []
    }
    
    private func analyzePlurals(input: String, target: String) -> [ErrorResult] {
        // è¤‡æ•°å½¢åˆ†æå®Ÿè£…
        // ç°¡æ˜“ç‰ˆå®Ÿè£… - å®Ÿéš›ã«ã¯ã‚ˆã‚Šé«˜åº¦ãªè‡ªç„¶è¨€èªå‡¦ç†ãŒå¿…è¦
        return []
    }
}
```

#### Week 8: MVPç‰ˆåŸºæœ¬å·®åˆ†è¡¨ç¤º
**ç›®æ¨™**: 3è‰²åŸºæœ¬å·®åˆ†è¡¨ç¤º
```swift
// MVPç‰ˆä½œæ¥­é …ç›®
âœ… BasicDifferenceView UIå®Ÿè£…
âœ… 3è‰²åŸºæœ¬è¡¨ç¤ºï¼ˆæ­£è§£ãƒ»ä¸æ­£è§£ãƒ»æœªå…¥åŠ›ï¼‰
âœ… æ–‡å­—å˜ä½å·®åˆ†è¡¨ç¤º
// ~~ã‚¨ãƒ©ãƒ¼ç¨®åˆ¥åˆ¥è¡¨ç¤º~~ â†’ v2.0
// ~~è¨­å®šç”»é¢~~ â†’ v2.0
// ~~è©³ç´°ã‚¨ãƒ©ãƒ¼è¡¨ç¤º~~ â†’ v2.0
// ~~å­¦ç¿’ææ¡ˆ~~ â†’ v2.0
```


**Phase 2 MVPç‰ˆå®ŒæˆåŸºæº–**:
- [ ] åŸºæœ¬TTSéŸ³å£°å‹•ä½œï¼ˆå…¨æ–‡å†ç”Ÿã®ã¿ï¼‰
- [ ] åŸºæœ¬ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆæ©Ÿèƒ½å‹•ä½œ
- [ ] 3è‰²åŸºæœ¬å·®åˆ†è¡¨ç¤ºå‹•ä½œ
- [ ] å®Ÿç”¨çš„ãªTTSå¿œç­”æ™‚é–“ï¼ˆæ•°å€¤ã¯è¨ˆæ¸¬å¾Œæ”¹å–„ï¼‰
- [ ] å®Ÿç”¨çš„ãªå·®åˆ†è¡¨ç¤ºé€Ÿåº¦ï¼ˆæ•°å€¤ã¯è¨ˆæ¸¬å¾Œæ”¹å–„ï¼‰

---

## ğŸ“… Phase 3: æœ€å°å¾©ç¿’ãƒ»ãƒ‡ãƒ¼ã‚¿å‡ºåŠ› (Week 9-11) - MVPç‰ˆç°¡ç´ åŒ–

### ğŸ¯ Phase 3 ç›®æ¨™
**æœ€å°é™ã®å­¦ç¿’æ”¯æ´ã‚·ã‚¹ãƒ†ãƒ ï¼ˆç°¡ç´ åŒ–ç‰ˆï¼‰**
- åŸºæœ¬é–“é•ã„ç®±æ‰€ãƒªã‚¹ãƒˆ
- ç°¡å˜ãªãƒ‡ãƒ¼ã‚¿å‡ºåŠ›ï¼ˆCSVï¼‰
- åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿
- æœ€å°é™ã®è¨­å®šæ©Ÿèƒ½

### Week 9-10: MVPç‰ˆåŸºæœ¬å¾©ç¿’ã‚·ã‚¹ãƒ†ãƒ 

#### Week 9: MVPç‰ˆBasicReviewSystemå®Ÿè£…
**ç›®æ¨™**: æœ€å°é™ã®é–“é•ã„ãƒªã‚¹ãƒˆæ©Ÿèƒ½
```swift
// MVPç‰ˆä½œæ¥­é …ç›®
âœ… BasicReviewListå®Ÿè£…
âœ… é–“é•ã„ç®±æ‰€ã®ç°¡å˜ãªä¸€è¦§è¡¨ç¤º
âœ… åŸºæœ¬çš„ãªé–“é•ã„æƒ…å ±è¡¨ç¤º
// ~~é–“éš”åå¾©ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ~~ â†’ v2.0
// ~~ç¿’å¾—åº¦è¿½è·¡~~ â†’ v2.0
// ~~å„ªå…ˆåº¦è¨ˆç®—~~ â†’ v2.0
```

#### Week 10: MVPç‰ˆåŸºæœ¬å¾©ç¿’UI
**ç›®æ¨™**: ç°¡å˜ãªå¾©ç¿’ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
```swift
// MVPç‰ˆä½œæ¥­é …ç›®
âœ… BasicReviewListViewå®Ÿè£…
âœ… é–“é•ã„ç®±æ‰€ã®åŸºæœ¬ä¸€è¦§è¡¨ç¤º
// ~~ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°~~ â†’ v2.0
// ~~TTSçµ±åˆ~~ â†’ v2.0
// ~~ç¿’å¾—åº¦å¯è¦–åŒ–~~ â†’ v2.0
```

### Week 11: MVPç‰ˆåŸºæœ¬ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›

#### Week 11: BasicDataExportå®Ÿè£…
**ç›®æ¨™**: æœ€å°é™ã®ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›æ©Ÿèƒ½
```swift
// MVPç‰ˆä½œæ¥­é …ç›®
âœ… BasicDataExportå®Ÿè£…
âœ… ç°¡å˜ãªCSVå‡ºåŠ›æ©Ÿèƒ½
âœ… ç·´ç¿’çµæœã®åŸºæœ¬ä¿å­˜
âœ… ãƒ‡ãƒ¼ã‚¿ã®åŸºæœ¬èª­ã¿è¾¼ã¿
// ~~JSONå‡ºåŠ›~~ â†’ v2.0
// ~~ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»å¾©å…ƒ~~ â†’ v2.0
// ~~è¤‡é›‘ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ~~ â†’ v2.0
// ~~çµ±è¨ˆãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰~~ â†’ v2.0
```

**Phase 3 MVPç‰ˆå®ŒæˆåŸºæº–**:
- [ ] åŸºæœ¬é–“é•ã„ãƒªã‚¹ãƒˆè¡¨ç¤ºå‹•ä½œ
- [ ] ç°¡å˜ãªCSVå‡ºåŠ›æ©Ÿèƒ½å‹•ä½œ
- [ ] åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿å‹•ä½œ
// ~~è¤‡é›‘ãªå¾©ç¿’ã‚·ã‚¹ãƒ†ãƒ ~~ â†’ v2.0
// ~~çµ±è¨ˆåˆ†æ~~ â†’ v2.0
// ~~ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—~~ â†’ v2.0

---

## ğŸ“… Phase 4: MVPç‰ˆæœ€çµ‚èª¿æ•´ãƒ»ãƒªãƒªãƒ¼ã‚¹ (Week 12)

### Week 12: MVPç‰ˆç·åˆãƒ†ã‚¹ãƒˆãƒ»ãƒªãƒªãƒ¼ã‚¹
```swift
// MVPç‰ˆä½œæ¥­é …ç›®
âœ… åŸºæœ¬æ©Ÿèƒ½çµ±åˆãƒ†ã‚¹ãƒˆ
âœ… åŸºæœ¬ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¤œè¨¼
âœ… ç°¡å˜ãªãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
âœ… åŸºæœ¬ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
âœ… MVPç‰ˆãƒªãƒªãƒ¼ã‚¹ãƒ“ãƒ«ãƒ‰ä½œæˆ
âœ… åŸºæœ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¬ã‚¤ãƒ‰ä½œæˆ
// ~~è©³ç´°ãªã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£æ¤œè¨¼~~ â†’ v2.0
// ~~App Storeæº–å‚™~~ â†’ v2.0
// ~~ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°ç´ æ~~ â†’ v2.0
```

---

## ğŸ”§ é–‹ç™ºç’°å¢ƒãƒ»ãƒ„ãƒ¼ãƒ«è¨­å®š

### é–‹ç™ºç’°å¢ƒè¦ä»¶
```yaml
Xcode: 15.0+
macOS: 14.0+ (é–‹ç™ºç’°å¢ƒ)
Target: macOS 14.0+ (é…å¸ƒ)
Swift: 5.9+
SwiftUI: 5.0+
```

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ
```
IELTSPractice/
â”œâ”€â”€ IELTSPractice/
â”‚   â”œâ”€â”€ App/
â”‚   â”‚   â”œâ”€â”€ IELTSPracticeApp.swift
â”‚   â”‚   â””â”€â”€ ContentView.swift
â”‚   â”œâ”€â”€ Models/
â”‚   â”‚   â”œâ”€â”€ IELTSTask.swift
â”‚   â”‚   â”œâ”€â”€ TypingResult.swift
â”‚   â”‚   â””â”€â”€ ReviewItem.swift
â”‚   â”œâ”€â”€ Views/
â”‚   â”‚   â”œâ”€â”€ Practice/
â”‚   â”‚   â”‚   â”œâ”€â”€ TypingPracticeView.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ TargetTextPanel.swift
â”‚   â”‚   â”‚   â””â”€â”€ InputArea.swift
â”‚   â”‚   â”œâ”€â”€ TTS/
â”‚   â”‚   â”‚   â””â”€â”€ TTSControlPanel.swift
â”‚   â”‚   â”œâ”€â”€ Analysis/
â”‚   â”‚   â”‚   â””â”€â”€ ErrorAnalysisPanel.swift
â”‚   â”‚   â””â”€â”€ Review/
â”‚   â”‚       â””â”€â”€ ReviewListView.swift
â”‚   â”œâ”€â”€ ViewModels/
â”‚   â”‚   â”œâ”€â”€ TypingTestManager.swift
â”‚   â”‚   â”œâ”€â”€ TTSManager.swift
â”‚   â”‚   â””â”€â”€ ReviewManager.swift
â”‚   â”œâ”€â”€ Services/
â”‚   â”‚   â”œâ”€â”€ ErrorAnalyzer.swift
â”‚   â”‚   â”œâ”€â”€ DifferenceCalculator.swift
â”‚   â”‚   â””â”€â”€ ExportManager.swift
â”‚   â”œâ”€â”€ Repositories/
â”‚   â”‚   â”œâ”€â”€ IELTSTaskRepository.swift
â”‚   â”‚   â””â”€â”€ TypingResultRepository.swift
â”‚   â””â”€â”€ Utils/
â”‚       â”œâ”€â”€ Extensions/
â”‚       â”œâ”€â”€ Helpers/
â”‚       â””â”€â”€ Constants/
â”œâ”€â”€ IELTSPracticeTests/
â””â”€â”€ IELTSPracticeUITests/
```

### ãƒ†ã‚¹ãƒˆæˆ¦ç•¥
```yaml
å˜ä½“ãƒ†ã‚¹ãƒˆ:
  - ã‚«ãƒãƒ¬ãƒƒã‚¸: 85%ä»¥ä¸Š
  - Manager/Serviceå±¤é‡ç‚¹
  - Repositoryå±¤å®Œå…¨ãƒ†ã‚¹ãƒˆ

çµ±åˆãƒ†ã‚¹ãƒˆ:
  - UI Flow ãƒ†ã‚¹ãƒˆ
  - ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼æ¤œè¨¼
  - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

UIãƒ†ã‚¹ãƒˆ:
  - ä¸»è¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ãƒ­ãƒ¼
  - ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
  - ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ
```

---

## ğŸ¯ å“è³ªä¿è¨¼ãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åŸºæº–

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™
| æŒ‡æ¨™ | ç›®æ¨™å€¤ | æ¸¬å®šæ–¹æ³• |
|------|--------|----------|
| å…¥åŠ›é…å»¶ | <50ms | ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦– |
| TTSå¿œç­” | <500ms | éŸ³å£°å†ç”Ÿé–‹å§‹ã¾ã§ |
| å·®åˆ†è¨ˆç®— | <100ms | 250èªãƒ†ã‚­ã‚¹ãƒˆå‡¦ç† |
| ã‚¢ãƒ—ãƒªèµ·å‹• | <2ç§’ | ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ¼ãƒˆ |
| ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ | <150MB | é€šå¸¸ä½¿ç”¨æ™‚ |

### å“è³ªåŸºæº–
```yaml
æ©Ÿèƒ½å“è³ª:
  - æ©Ÿèƒ½å®Œå…¨æ€§: 100%
  - æ©Ÿèƒ½æ­£ç¢ºæ€§: 95%ä»¥ä¸Š
  - æ©Ÿèƒ½é©åˆæ€§: IELTSè¦ä»¶100%é©åˆ

ä¿¡é ¼æ€§:
  - ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ç‡: <0.01%
  - ãƒ‡ãƒ¼ã‚¿æå¤±ç‡: 0%
  - å¾©æ—§æ™‚é–“: <3ç§’

ä½¿ã„ã‚„ã™ã•:
  - å­¦ç¿’åŠ¹ç‡: 3ã‚¯ãƒªãƒƒã‚¯ä»¥å†…ã§ç·´ç¿’é–‹å§‹
  - ã‚¨ãƒ©ãƒ¼å›å¾©: æ˜ç¢ºãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  - ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£: WCAG 2.1 AAæº–æ‹ 
```

---

## ğŸ“Š ãƒªã‚¹ã‚¯ç®¡ç†ãƒ»ç·©å’Œç­–

### æŠ€è¡“ãƒªã‚¹ã‚¯
| ãƒªã‚¹ã‚¯ | å½±éŸ¿åº¦ | ç™ºç”Ÿç¢ºç‡ | ç·©å’Œç­– |
|--------|--------|----------|--------|
| TTSéŸ³å£°å“è³ª | High | Medium | è¤‡æ•°éŸ³å£°ã‚¨ãƒ³ã‚¸ãƒ³æ¤œè¨ |
| ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†æ€§èƒ½ | High | Medium | ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æœ€é©åŒ– |
| ã‚¨ãƒ©ãƒ¼åˆ†æç²¾åº¦ | Medium | High | æ®µéšçš„ç²¾åº¦å‘ä¸Š |
| SwiftDataäº’æ›æ€§ | Low | Low | Core Dataä½µç”¨ |

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒªã‚¹ã‚¯
```yaml
ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«é…å»¶:
  - ç·©å’Œ: é€±æ¬¡ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ç®¡ç†
  - å¯¾å¿œ: æ©Ÿèƒ½å„ªå…ˆåº¦èª¿æ•´

å“è³ªä½ä¸‹:
  - ç·©å’Œ: ç¶™ç¶šçš„ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
  - å¯¾å¿œ: å“è³ªã‚²ãƒ¼ãƒˆå¼·åŒ–

è¦ä»¶å¤‰æ›´:
  - ç·©å’Œ: IELTSè¦ä»¶å›ºå®šåŒ–
  - å¯¾å¿œ: å¤‰æ›´å½±éŸ¿åˆ†æ
```

---

## ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ»ãƒªãƒªãƒ¼ã‚¹è¨ˆç”»

### ãƒªãƒªãƒ¼ã‚¹æˆ¦ç•¥
```yaml
MVPç‰ˆ (Phase 1å®Œäº†):
  - å†…éƒ¨ãƒ†ã‚¹ãƒˆç‰ˆ
  - åŸºæœ¬æ©Ÿèƒ½æ¤œè¨¼
  - ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ

Betaç‰ˆ (Phase 2å®Œäº†):
  - é™å®šãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ†ã‚¹ãƒˆ
  - ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åé›†
  - æ©Ÿèƒ½æ”¹å–„

è£½å“ç‰ˆ (Phase 4å®Œäº†):
  - App Storeç”³è«‹
  - ä¸€èˆ¬ãƒªãƒªãƒ¼ã‚¹
  - ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°é–‹å§‹
```

### é…å¸ƒè¨ˆç”»
```yaml
é…å¸ƒæ–¹æ³•:
  - Mac App Store (ãƒ¡ã‚¤ãƒ³)
  - ç›´æ¥é…å¸ƒ (DMG)
  - æ•™è‚²æ©Ÿé–¢å‘ã‘ (ãƒœãƒªãƒ¥ãƒ¼ãƒ )

ä¾¡æ ¼æˆ¦ç•¥:
  - è²·ã„åˆ‡ã‚Š: Â¥2,980
  - æ•™è‚²å‰²å¼•: Â¥1,980
  - å°†æ¥: ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æ¤œè¨
```

---

## ğŸ“ é€²æ—ç®¡ç†ãƒ»å ±å‘Šä½“åˆ¶

### é€±æ¬¡é€²æ—ãƒ¬ãƒãƒ¼ãƒˆ
```yaml
å ±å‘Šå†…å®¹:
  - å®Œäº†ä½œæ¥­é …ç›®
  - æ¬¡é€±äºˆå®šä½œæ¥­
  - èª²é¡Œãƒ»ãƒ–ãƒ­ãƒƒã‚«ãƒ¼
  - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™
  - å“è³ªæŒ‡æ¨™

ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒã‚¤ãƒ³ãƒˆ:
  - æ©Ÿèƒ½å®Œæˆåº¦
  - å“è³ªåŸºæº–é”æˆ
  - ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«éµå®ˆ
  - ãƒªã‚¹ã‚¯çŠ¶æ³
```

### ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ç®¡ç†
```yaml
Phaseå®Œäº†åŸºæº–:
  - å…¨æ©Ÿèƒ½é …ç›®å®Œäº†
  - å“è³ªåŸºæº–é”æˆ
  - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åŸºæº–é”æˆ
  - ãƒ†ã‚¹ãƒˆå®Œäº†
  - ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå®Œæˆ

Go/No-Goåˆ¤å®š:
  - æ©Ÿèƒ½å®Œå…¨æ€§ãƒã‚§ãƒƒã‚¯
  - å“è³ªåŸºæº–è©•ä¾¡
  - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
  - ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£æ¤œè¨¼
```

---

---

## ğŸ¯ MVPç‰ˆé–‹ç™ºåŠ¹æœã¾ã¨ã‚

### é–‹ç™ºåŠ¹ç‡å‘ä¸Š
- **ç·æœŸé–“çŸ­ç¸®**: 20é€±é–“ â†’ 12é€±é–“ï¼ˆ40%çŸ­ç¸®ï¼‰
- **ç·å·¥æ•°å‰Šæ¸›**: 920æ™‚é–“ â†’ 450æ™‚é–“ï¼ˆ51%å‰Šæ¸›ï¼‰
- **é–‹ç™ºãƒªã‚¹ã‚¯è»½æ¸›**: è¤‡é›‘ãªæ©Ÿèƒ½ã‚’å¾Œå›ã—ã«ã—ã¦ãƒªã‚¹ã‚¯ã‚’æœ€å°åŒ–

### MVPç‰ˆã®åˆ©ç‚¹
1. **è¿…é€Ÿãªãƒªãƒªãƒ¼ã‚¹**: 3ãƒ¶æœˆã§ã®å¸‚å ´æŠ•å…¥
2. **æ—©æœŸãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®å®Ÿéš›ã®è¦æ±‚æŠŠæ¡
3. **ãƒªã‚¹ã‚¯è»½æ¸›**: å°ã•ãå§‹ã‚ã¦æ®µéšçš„ã«æ”¹å–„
4. **é–‹ç™ºåŠ¹ç‡**: ã‚³ã‚¢æ©Ÿèƒ½ã«é›†ä¸­ã—ãŸåŠ¹ç‡çš„ãªé–‹ç™º

### v2.0ã¸ã®ç§»è¡Œæˆ¦ç•¥
MVPç‰ˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’åŸºã«ã€æœ€ã‚‚è¦æ±‚ã®é«˜ã„æ©Ÿèƒ½ã‹ã‚‰é †æ¬¡v2.0ã§å®Ÿè£…:
- **é«˜å„ªå…ˆ**: è©³ç´°ã‚¨ãƒ©ãƒ¼åˆ†æã€æ–‡ãƒ»ãƒ•ãƒ¬ãƒ¼ã‚ºå˜ä½TTS
- **ä¸­å„ªå…ˆ**: å¾©ç¿’ã‚·ã‚¹ãƒ†ãƒ ã€çµ±è¨ˆãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰  
- **ä½å„ªå…ˆ**: é«˜åº¦ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã€è¤‡é›‘ãªãƒ‡ãƒ¼ã‚¿å‡ºåŠ›

---

*ã“ã®MVPç‰ˆå®Ÿè£…è¨ˆç”»æ›¸ã¯ã€IELTS Writing Practice Appã®è¿…é€Ÿãªé–‹ç™ºã¨ãƒªãƒªãƒ¼ã‚¹ã‚’å®Ÿç¾ã—ã€ã‚³ã‚¢æ©Ÿèƒ½ã«é›†ä¸­ã—ãŸå®Ÿç”¨çš„ãªIELTSã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç·´ç¿’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Œæˆã‚’ç›®æŒ‡ã™å®Ÿè£…ã‚¬ã‚¤ãƒ‰ã§ã™ã€‚*